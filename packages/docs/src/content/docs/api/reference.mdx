---
title: API Reference
description: "Detailed API reference for Subnetter's programmatic interfaces."
---

import { Aside, Tabs, TabItem, Card, CardGrid } from '@astrojs/starlight/components';

<Card title="TypeDoc Generated Documentation" icon="document">
  For the most comprehensive and up-to-date API details, visit the [Generated API Documentation](/subnetter/typedoc/index.html).
</Card>

This document provides detailed reference information for developers using Subnetter programmatically.

## Table of Contents
- [Installation](#installation)
- [Configuration](#configuration)
- [CidrAllocator](#cidrallocator)
- [Output Functions](#output-functions)
- [Validation](#validation)
- [Error Handling](#error-handling)
- [Logging](#logging)
- [CIDR Utilities](#cidr-utilities)

---

## Installation

```bash
# Core package for programmatic use
npm install @subnetter/core

# Optional: NetBox integration
npm install @subnetter/netbox

# Optional: Low-level CIDR utilities
npm install @subnetter/cidr-utils
```

---

## Configuration

### Config Interface

The main configuration interface for CIDR allocation:

```typescript
interface Config {
  /** Base CIDR block to allocate from (e.g., "10.0.0.0/8") */
  baseCidr: string;

  /** Optional prefix lengths for hierarchy levels */
  prefixLengths?: {
    account?: number;   // Prefix for account-level CIDR
    region?: number;    // Prefix for region-level CIDR
    az?: number;        // Prefix for AZ-level CIDR
  };

  /** List of cloud providers (can be inferred from accounts) */
  cloudProviders?: string[];

  /** Account configurations */
  accounts: Account[];

  /** Subnet types with their prefix lengths */
  subnetTypes: Record<string, number>;
}

interface Account {
  /** Account name (must be unique) */
  name: string;

  /** Cloud-specific configurations */
  clouds: Record<string, CloudConfig>;
}

interface CloudConfig {
  /** Optional override CIDR for this cloud */
  baseCidr?: string;

  /** List of regions to allocate in */
  regions: string[];
}
```

### loadConfig

Loads and validates a configuration file.

```typescript
function loadConfig(configPath: string): Promise<Config>
```

**Parameters:**
- `configPath`: Path to JSON or YAML configuration file

**Returns:** Promise resolving to a validated Config object

**Throws:** `ConfigurationError` if file is invalid or doesn't exist

**Example:**
```typescript
import { loadConfig } from '@subnetter/core';

const config = await loadConfig('./config.json');
// or
const yamlConfig = await loadConfig('./config.yaml');
```

### validateConfig

Validates a configuration object programmatically.

```typescript
function validateConfig(config: unknown): Config
```

**Parameters:**
- `config`: Configuration object to validate

**Returns:** Validated Config object

**Throws:** `ConfigurationError` if validation fails

**Example:**
```typescript
import { validateConfig } from '@subnetter/core';

const config = validateConfig({
  baseCidr: '10.0.0.0/8',
  accounts: [{
    name: 'production',
    clouds: {
      aws: { regions: ['us-east-1'] }
    }
  }],
  subnetTypes: {
    public: 26,
    private: 24
  }
});
```

---

## CidrAllocator

Main class for hierarchical CIDR allocation.

```typescript
class CidrAllocator {
  constructor(config: Config);
  generateAllocations(): Allocation[];
}
```

### Constructor

Creates a new allocator instance.

**Parameters:**
- `config`: Validated Config object

**Throws:** `ConfigurationError` if config is invalid

### generateAllocations

Generates all subnet allocations.

**Returns:** Array of Allocation objects

**Throws:** `AllocationError` if allocation fails

### Allocation Interface

```typescript
interface Allocation {
  /** Account name */
  accountName: string;

  /** VPC name (typically account-region) */
  vpcName: string;

  /** Cloud provider (aws, azure, gcp) */
  cloudProvider: string;

  /** Region name (e.g., us-east-1) */
  regionName: string;

  /** Availability zone (e.g., us-east-1a) */
  availabilityZone: string;

  /** CIDR allocated to the region */
  regionCidr: string;

  /** CIDR allocated to the VPC */
  vpcCidr: string;

  /** CIDR allocated to the AZ */
  azCidr: string;

  /** CIDR allocated to this subnet */
  subnetCidr: string;

  /** Subnet role/type name */
  subnetRole: string;

  /** Number of usable IP addresses */
  usableIps: number;
}
```

**Example:**
```typescript
import { loadConfig, CidrAllocator } from '@subnetter/core';

const config = await loadConfig('./config.json');
const allocator = new CidrAllocator(config);
const allocations = allocator.generateAllocations();

allocations.forEach(alloc => {
  console.log(`${alloc.accountName}/${alloc.regionName}/${alloc.availabilityZone}`);
  console.log(`  ${alloc.subnetRole}: ${alloc.subnetCidr} (${alloc.usableIps} IPs)`);
});
```

---

## Output Functions

### writeAllocationsToCsv

Writes allocations to a CSV file.

```typescript
function writeAllocationsToCsv(
  allocations: Allocation[],
  outputPath: string
): Promise<void>
```

**Parameters:**
- `allocations`: Array of Allocation objects
- `outputPath`: Path to output CSV file

**Returns:** Promise that resolves when file is written

**Throws:** `IOError` if writing fails

**Example:**
```typescript
import { writeAllocationsToCsv } from '@subnetter/core';

await writeAllocationsToCsv(allocations, './allocations.csv');
```

### filterAllocationsByProvider

Filters allocations by cloud provider.

```typescript
function filterAllocationsByProvider(
  allocations: Allocation[],
  provider: string
): Allocation[]
```

**Parameters:**
- `allocations`: Array of Allocation objects
- `provider`: Cloud provider name (case-insensitive)

**Returns:** Filtered array of allocations

**Example:**
```typescript
import { filterAllocationsByProvider } from '@subnetter/core';

const awsAllocations = filterAllocationsByProvider(allocations, 'aws');
const azureAllocations = filterAllocationsByProvider(allocations, 'azure');
```

---

## Validation

### validateNoOverlappingCidrs

Validates that no allocations have overlapping CIDRs.

```typescript
function validateNoOverlappingCidrs(
  allocations: Allocation[],
  throwOnOverlap?: boolean
): ValidationResult

interface ValidationResult {
  valid: boolean;
  overlaps: OverlapInfo[];
}

interface OverlapInfo {
  cidr1: string;
  cidr2: string;
  allocation1: Allocation;
  allocation2: Allocation;
}
```

**Parameters:**
- `allocations`: Array of Allocation objects
- `throwOnOverlap`: If true, throws on first overlap (default: false)

**Returns:** Validation result with overlap details

**Throws:** `ValidationError` if throwOnOverlap is true and overlaps exist

**Example:**
```typescript
import { validateNoOverlappingCidrs } from '@subnetter/core';

const result = validateNoOverlappingCidrs(allocations);

if (!result.valid) {
  console.error(`Found ${result.overlaps.length} overlaps:`);
  result.overlaps.forEach(overlap => {
    console.error(`  ${overlap.cidr1} â†” ${overlap.cidr2}`);
  });
}
```

---

## Error Handling

Subnetter provides a comprehensive error hierarchy:

```typescript
// Base error class
class SubnetterError extends Error {
  readonly code?: ErrorCode;
  readonly context?: Record<string, unknown>;

  getHelpText(): string;
  getContextString(): string;
}

// Specific error types
class ConfigurationError extends SubnetterError {}
class AllocationError extends SubnetterError {}
class IOError extends SubnetterError {}
class ValidationError extends SubnetterError {}
class CloudProviderError extends SubnetterError {}

// Error codes
enum ErrorCode {
  // Configuration errors
  CONFIG_FILE_NOT_FOUND = 'CONFIG_FILE_NOT_FOUND',
  CONFIG_PARSE_ERROR = 'CONFIG_PARSE_ERROR',
  INVALID_CONFIG_FORMAT = 'INVALID_CONFIG_FORMAT',
  MISSING_REQUIRED_FIELD = 'MISSING_REQUIRED_FIELD',

  // CIDR errors
  INVALID_CIDR_FORMAT = 'INVALID_CIDR_FORMAT',
  CIDR_OVERLAP = 'CIDR_OVERLAP',
  INSUFFICIENT_SPACE = 'INSUFFICIENT_SPACE',

  // I/O errors
  FILE_READ_ERROR = 'FILE_READ_ERROR',
  FILE_WRITE_ERROR = 'FILE_WRITE_ERROR',

  // General
  INVALID_OPERATION = 'INVALID_OPERATION',
}
```

**Example:**
```typescript
import {
  loadConfig,
  CidrAllocator,
  SubnetterError,
  ConfigurationError,
  AllocationError,
  ErrorCode
} from '@subnetter/core';

try {
  const config = await loadConfig('./config.json');
  const allocator = new CidrAllocator(config);
  const allocations = allocator.generateAllocations();
} catch (error) {
  if (error instanceof ConfigurationError) {
    console.error(`Config error [${error.code}]: ${error.message}`);
    console.log('Help:', error.getHelpText());
  } else if (error instanceof AllocationError) {
    console.error('Allocation failed:', error.message);
    if (error.code === ErrorCode.INSUFFICIENT_SPACE) {
      console.log('Try using smaller prefix lengths or a larger base CIDR');
    }
  } else if (error instanceof SubnetterError) {
    console.error(`Error: ${error.message}`);
  }
}
```

<Aside type="note">
  For backward compatibility, `CidrError` and `ConfigValidationError` are still exported as aliases.
</Aside>

---

## Logging

Subnetter provides a configurable logging system:

```typescript
import {
  createLogger,
  configureLogger,
  LogLevel,
  parseLogLevel,
  type Logger
} from '@subnetter/core';

// Configure global logging
configureLogger({
  level: LogLevel.DEBUG,  // SILENT, ERROR, WARN, INFO, DEBUG, TRACE
  useColor: true,
  timestamps: true
});

// Create named loggers
const logger = createLogger('MyApp');
logger.error('Something failed');
logger.warn('Warning message');
logger.info('Informational message');
logger.debug('Debug details');
logger.trace('Trace-level detail');

// Parse log level from string
const level = parseLogLevel('debug');  // LogLevel.DEBUG
```

---

## CIDR Utilities

The `@subnetter/core` package re-exports common CIDR utilities:

### isValidIpv4Cidr

```typescript
function isValidIpv4Cidr(cidr: string): boolean
```

Returns true if the string is a valid IPv4 CIDR.

### calculateUsableIps

```typescript
function calculateUsableIps(cidr: string): number
```

Returns the number of usable IP addresses (total - 2 for network/broadcast).

### doCidrsOverlap

```typescript
function doCidrsOverlap(cidr1: string, cidr2: string): boolean
```

Returns true if two CIDRs overlap.

### subdivideIpv4Cidr

```typescript
function subdivideIpv4Cidr(cidr: string, newPrefixLength: number): string[]
```

Subdivides a CIDR into smaller blocks of the given prefix length.

### calculateOptimalPrefixLength

```typescript
function calculateOptimalPrefixLength(cidr: string, count: number): number
```

Calculates the optimal prefix length to create at least `count` subnets.

### calculateRequiredPrefixLength

```typescript
function calculateRequiredPrefixLength(requiredAddresses: number): number
```

Calculates the prefix length needed for the given number of addresses.

**Example:**
```typescript
import {
  isValidIpv4Cidr,
  calculateUsableIps,
  doCidrsOverlap,
  subdivideIpv4Cidr,
  calculateOptimalPrefixLength,
  calculateRequiredPrefixLength
} from '@subnetter/core';

// Validation
isValidIpv4Cidr('10.0.0.0/24');  // true
isValidIpv4Cidr('10.0.0.0/33');  // false

// Usable IPs
calculateUsableIps('10.0.0.0/24');  // 254
calculateUsableIps('10.0.0.0/31');  // 2 (RFC 3021)
calculateUsableIps('10.0.0.0/32');  // 1

// Overlap detection
doCidrsOverlap('10.0.0.0/24', '10.0.1.0/24');    // false
doCidrsOverlap('10.0.0.0/24', '10.0.0.128/25');  // true

// Subdivision
subdivideIpv4Cidr('10.0.0.0/24', 26);
// ['10.0.0.0/26', '10.0.0.64/26', '10.0.0.128/26', '10.0.0.192/26']

// Prefix calculations
calculateOptimalPrefixLength('10.0.0.0/16', 5);   // 19 (creates 8 subnets)
calculateRequiredPrefixLength(250);               // 24 (provides 254 IPs)
```

---

## Advanced Components

For advanced use cases, these internal components are also exported:

```typescript
import {
  SubnetAllocator,      // Low-level subnet allocation
  CidrTracker,          // Tracks allocated CIDRs
  ContiguousAllocator,  // Allocates sequential blocks
  HierarchicalAllocator // Hierarchical allocation strategy
} from '@subnetter/core';
```

<Aside type="caution">
  These components are primarily for internal use and testing. Their APIs may change between versions.
</Aside>
